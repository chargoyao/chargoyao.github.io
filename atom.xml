<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chargoyao</title>
  
  <subtitle>姚东博客</subtitle>
  <link href="https://chargoyao.github.io/atom.xml" rel="self"/>
  
  <link href="https://chargoyao.github.io/"/>
  <updated>2020-09-21T14:13:39.410Z</updated>
  <id>https://chargoyao.github.io/</id>
  
  <author>
    <name>chargo yao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react useEffect</title>
    <link href="https://chargoyao.github.io/2020/09/08/react-useEffect/"/>
    <id>https://chargoyao.github.io/2020/09/08/react-useEffect/</id>
    <published>2020-09-08T15:46:21.000Z</published>
    <updated>2020-09-21T14:13:39.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Single-Responsiblility"><a href="#Single-Responsiblility" class="headerlink" title="Single Responsiblility"></a>Single Responsiblility</h1><p>在开发基于hook的react运用的时候可以在Function component中使用多个useEffect,既然是基于function component来组织react代码，有一个基本原则还是需要去留意的，<strong>它就是单一职责</strong>。<br>将useEffect拆分为更小的职责更单一的函数，有利于防止&#39;意外&#39;的发生，尤其在使用dependency array的时候。<br>举个的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">20</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;name changed&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;age changed&quot;</span>);</span><br><span class="line">  &#125;, [name, age]);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleChangeName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setName(<span class="string">&quot;joyce&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleChangeAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setAge(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      name: &lt;span&gt;&#123;name&#125;&lt;/span&gt;</span><br><span class="line">      age: &lt;span&gt;&#123;age&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleChangeName&#125;&gt;change name&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleChangeAge&#125;&gt;change age&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上代码，当name和age任何一个值改变的时候，都会触发更新(例子中表现为两个console.log都会被打印出来)，这显然是不太妥当的写法。应该只在name改变的时候打印&#39;name changed&#39;age改变的时候打印&#39;age changed&#39;。<br>所以应该把useEffect拆分为更小且职责更单一的函数。如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">20</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;name changed&quot;</span>);</span><br><span class="line">  &#125;, [name]);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;age changed&quot;</span>);</span><br><span class="line">    <span class="comment">// console.log(&quot;age changed&quot;);</span></span><br><span class="line">  &#125;, [age]);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleChangeName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setName(<span class="string">&quot;joyce&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleChangeAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setAge(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      name: &lt;span&gt;&#123;name&#125;&lt;/span&gt;</span><br><span class="line">      age: &lt;span&gt;&#123;age&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleChangeName&#125;&gt;change name&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleChangeAge&#125;&gt;change age&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在上述例子中，如果name和age的状态在需求开发中是两个完全独立的，更好的方式，应该是将name的状态和age状态，分别独立出来写成custom hook的形式。这样代码在可读性和维护性上也会更好。</strong></p><h1 id="在useEffect中使用条件判断语句"><a href="#在useEffect中使用条件判断语句" class="headerlink" title="在useEffect中使用条件判断语句"></a>在useEffect中使用条件判断语句</h1><p>当你在useEffect中使用条件语句的时候，有一些细节问题可能你并未能注意到。来举个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Hello = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="comment">// num小于5的时候执行某些操作。</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;设置某些操作或者状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在num更新更新之后，清除上一次的操作或者状态。</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [num]);</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setNum(num + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &lt;div onClick=&#123;handleClick&#125;&gt;<span class="built_in">number</span>: &#123;num&#125;&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Hello;</span><br></pre></td></tr></table></figure><p>如上示例代码，在每次点击div元素的时候num状态进行累加，当num小于3的时候执行某些状态的设置操作等等，这里要表达的需求大致是，当num小于3的时候执行订阅或者状态的设置，随后在num更新之后清除上一次的订阅或者状态设置。<br>可是以上示例的代码虽然在表现上符合我们的预期，但是，在后续累加大于等于3之后useEffect返回的函数都会被执行。这显然是存在代码冗余执行的问题。所以在useEffect面临条件判断的场景下，可以显示return来防止此类问题。如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Hello = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在num更新更新之后，清除上一次的操作或者状态。</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [num]);</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setNum(num + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &lt;div onClick=&#123;handleClick&#125;&gt;<span class="built_in">number</span>: &#123;num&#125;&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Hello;</span><br></pre></td></tr></table></figure><p>这样当num大于等于3之后，useEffect将不会执行相关的&#39;清理&#39;操作，更符合预期效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Single-Responsiblility&quot;&gt;&lt;a href=&quot;#Single-Responsiblility&quot; class=&quot;headerlink&quot; title=&quot;Single Responsiblility&quot;&gt;&lt;/a&gt;Single Responsiblili</summary>
      
    
    
    
    <category term="react" scheme="https://chargoyao.github.io/categories/react/"/>
    
    
    <category term="react hook" scheme="https://chargoyao.github.io/tags/react-hook/"/>
    
  </entry>
  
  <entry>
    <title>Javascript function</title>
    <link href="https://chargoyao.github.io/2020/09/08/Javascript-function/"/>
    <id>https://chargoyao.github.io/2020/09/08/Javascript-function/</id>
    <published>2020-09-08T07:42:43.000Z</published>
    <updated>2020-09-21T14:37:41.431Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript语言支持functional programming,其中一个主要的原因是函数在js中是作为first-class citizens存在的。在js中函数究竟有哪些用法？</p><h1 id="Pure-Function"><a href="#Pure-Function" class="headerlink" title="Pure Function"></a>Pure Function</h1><p>在函数式编程中其中有一个很重要的概念，那就是纯函数，究竟什么样的函数才能称为纯函数呢？<br>纯函数应该满足下面两个条件：<br>1.给定相同的参数总是返回相同的结果。<br>2.在函数执行期间不存在side-effect(副作用)。</p><p>例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * a + <span class="number">10</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当a的值是相同的时候，add函数总是返回相同的值，并且函数的外部不存在任何的side-effect。(add函数的执行并不依赖于任何外部环境的变量)。所以这里的add函数是个pure function。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">const</span> num: <span class="function">() =&gt;</span> <span class="built_in">number</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>此处的num函数在每次调用的时候都返回不同的值，因此它不是一个纯函数。</p><h1 id="Why-pure-function"><a href="#Why-pure-function" class="headerlink" title="Why pure function?"></a>Why pure function?</h1><p>为什么要有纯函数的概念呢？它的优点在哪里？纯函数主要有以下优点：</p><h2 id="纯函数可以让代码更易测试"><a href="#纯函数可以让代码更易测试" class="headerlink" title="纯函数可以让代码更易测试"></a>纯函数可以让代码更易测试</h2><p>比如下面这个具有副作用的函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outsideVar = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// calculateValue函数依赖外部环境变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> calculateValue = <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> value * <span class="number">2</span> + outsideVar;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;测试不纯的函数&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;should be 12&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(calculateValue(<span class="number">1</span>)).toBe(<span class="number">12</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的测试是可以通过，但是假设如果外部环境的变量被改变了的话，这条测试可能就无法测试通过。此时的calculateValue函数就难以测试。如果要修复这样的问题，我们可以通过将外部环境变量移入calculateValue函数中来解决。</p><h2 id="并发执行代码"><a href="#并发执行代码" class="headerlink" title="并发执行代码"></a>并发执行代码</h2><p>由于纯函数并不会改变它的环境，因此纯函数可以并发的执行代码。也就是说你不需要担心同步的问题。当然javascript并没有真正的多线程用来并发的执行代码。但是当你的项目使用了WebWorker之后，你可能会用WebWorker来并发的执行多任务。比如有个非纯函数的代码版本：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;python&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;php&#x27;</span>;</span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;      </span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;python&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;business logic&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码假设D1线程执行了foo函数，D2线程执行了bar函数。且D1在D2之前执行，由于二者皆依赖于全局变量，最终的执行结果可能并不会是你想要的。因此可以将上述的两个函数改造为纯函数，移动name变量，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;php&#x27;</span>;</span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;      </span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;python&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;business logic&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以放心的并发的执行这两个函数了，且不必但是顺序的问题。</p><h1 id="high-order-function"><a href="#high-order-function" class="headerlink" title="high-order function"></a>high-order function</h1><h2 id="什么是高阶函数？"><a href="#什么是高阶函数？" class="headerlink" title="什么是高阶函数？"></a>什么是高阶函数？</h2><p>定义：以一个或者多个函数作为参数，或者函数返回的是一个函数。或者如上两者情况皆有的函数称为高阶函数。<br>借助于高阶函数可以让你的代码更具灵活性，同时也更加有效和精炼。<br>打个比方，比如有一个正整数的数组，现在需要生成一个新的数组，且数组的元素是原来数组元素值的两倍。<br>在不使用高阶函数的时候你可能会这么写代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">  arr2.push(arr1[i] * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在js中有个操作数组对象的方法map，map方法的参数传入指定的函数会返回一个新的数组，这个map其实就是一个high-order function。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.map(<span class="function">(<span class="params">item: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> * <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>通过使用这样的高阶函数可以有效增强代码的可读性，这样的代码更像是一种声明式编程的范式，而非命令式编程。</p><h1 id="Cache-Function"><a href="#Cache-Function" class="headerlink" title="Cache Function"></a>Cache Function</h1><p>比如有如下需要一定计算开销的pure function。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computedValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里有开销大的计算</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;computing&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;computed value&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用pure function相同的参数总是返回相同结果的特性，就可以缓存函数的计算结果，如果函数的参数是相同的就可以从内存中直接返回结果，而无需再一次执行函数。从而提高代码执行的性能，其实也就是利用空间换时间的概念。<br>通过如下的缓存函数可以缓存pure function的计算结果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cacheWrapper</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cacheMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cachedFn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cacheMap[str] || (cacheMap[str] = fn(str));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lazy-Function"><a href="#Lazy-Function" class="headerlink" title="Lazy Function"></a>Lazy Function</h1><p>有时候函数体会包含一些条件判断语句，有时候这些条件判断语句只需要执行一次。可以在函数首次执行完毕之后，删除这些判断语句从而达到提高函数执行性能的目的。在之后函数再一次执行的时候则不需要经过条件语句的判断，这样的技术称为lazy function。<br>举个例子，在你需要兼容老式的IE浏览器的时候，可能会写如下的兼容代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">type, element, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    element.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用这个addEvent函数的时候，都要执行一遍if语句的条件判断，通过lazy function技术可以这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">type, element, fn</span>) </span>&#123;</span><br><span class="line">      element.addEvenListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">type, element, fn</span>) </span>&#123;</span><br><span class="line">      element.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  addEvent(type, element, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于一些函数中的条件判断语句只需要执行一次的场景，可以通过lazy function来进行优化，第一次函数中的条件判断语句被执行之后，原函数的函数体被新的无条件判断语句的函数覆盖。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Javascript语言支持functional programming,其中一个主要的原因是函数在js中是作为first-class citizens存在的。在js中函数究竟有哪些用法？&lt;/p&gt;
&lt;h1 id=&quot;Pure-Function&quot;&gt;&lt;a href=&quot;#Pure-</summary>
      
    
    
    
    <category term="functional programming" scheme="https://chargoyao.github.io/categories/functional-programming/"/>
    
    
    <category term="javascript" scheme="https://chargoyao.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>tree shaking</title>
    <link href="https://chargoyao.github.io/2020/09/06/tree-shaking/"/>
    <id>https://chargoyao.github.io/2020/09/06/tree-shaking/</id>
    <published>2020-09-06T14:30:11.000Z</published>
    <updated>2020-09-06T16:07:58.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h1><p>webpack通过借鉴rollup开始在webpack2中支持Tree Shaking，在webpack4中是默认支持Tree Shaking，如果你在打包的时候设置mode为production，webpack就会默认开启Tree Shaking。<br>使用方法：<br>1.webpack mode属性设置为production<br>2..babelrc里设置modules: false</p><h1 id="什么是Tree-Shaking-摇树优化？翻译起来感觉实在是怪"><a href="#什么是Tree-Shaking-摇树优化？翻译起来感觉实在是怪" class="headerlink" title="什么是Tree Shaking?(摇树优化？翻译起来感觉实在是怪)"></a>什么是Tree Shaking?(摇树优化？翻译起来感觉实在是怪)</h1><p>一个模块中可能有多个方法，在这种情况下，只要其中的方法使用到了，则整个文件都被会打包到bundle里面去，<br>tree shaking就是只把用到的方法打包进bundle，没用到的方法会被remove掉。</p><p>要了解tree Shaking的原理首先必须要提的是Dead Code Elimination(死码消除)，DCE是一种编译优化技术，它的用途是移除对程序运行结果没有任何影响的代码。</p><h1 id="哪些是对于程序运行没有任何影响的代码呢？"><a href="#哪些是对于程序运行没有任何影响的代码呢？" class="headerlink" title="哪些是对于程序运行没有任何影响的代码呢？"></a>哪些是对于程序运行没有任何影响的代码呢？</h1><p>1.代码不会被执行，且无法到达，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;unused code&#x27;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.代码的执行结果没有被用到<br>比如你写了一个函数，这个函数返回一个结果，这个结果的值在代码中并未使用到，或者你调用这个函数赋值给一个变量，但是变量的值却没有在代码中使用。<br>3.死变量<br>你写了一系列的代码去改变你声明的变量的值，但是最后变量并没有在代码中被用到。</p><p>以上的情况统称为DCE，tree Shaking也是利用了这些特性从而来判断哪些代码是dead code从而删除它。</p><h1 id="Tree-Shaking的原理"><a href="#Tree-Shaking的原理" class="headerlink" title="Tree Shaking的原理"></a>Tree Shaking的原理</h1><p>tree shaking其实就是利用了ES module的特点来进行shake<br>1.只能作为模块顶层的语句出现<br>2.import的模块名字只能是字符串常量，也就是说你不能动态的去设置import的内容<br>3.import的binding是不可变的<br><strong>显然commonJS是不具备ES6的特点的</strong>，commonJS是可以动态的require。在不同的条件下去require不同的模块。Tree shaking最本质的是对模块的代码进行静态的分析,因此Tree Shaking需要ES6这样的模块特性。<br>也就是说在代码编译阶段就要确定哪些代码是你需要的或者必须的，而不能在代码运行的时候再进行分析哪些代码是需要的。Tree shaking知道哪些代码没用之后会增加注释和标记，然后会在uglify阶段进行remove的操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tree-Shaking&quot;&gt;&lt;a href=&quot;#Tree-Shaking&quot; class=&quot;headerlink&quot; title=&quot;Tree Shaking&quot;&gt;&lt;/a&gt;Tree Shaking&lt;/h1&gt;&lt;p&gt;webpack通过借鉴rollup开始在webpack2中支</summary>
      
    
    
    
    <category term="webpack" scheme="https://chargoyao.github.io/categories/webpack/"/>
    
    
    <category term="tree shaking" scheme="https://chargoyao.github.io/tags/tree-shaking/"/>
    
  </entry>
  
</feed>
