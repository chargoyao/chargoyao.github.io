[{"title":"react useEffect","url":"/chargoyao.github.io/2020/09/08/react-useEffect/","content":"Single Responsiblility在开发基于hook的react运用的时候可以在Function component中使用多个useEffect,既然是基于function component来组织react代码，有一个基本原则还是需要去留意的，它就是单一职责。将useEffect拆分为更小的职责更单一的函数，有利于防止&#39;意外&#39;的发生，尤其在使用dependency array的时候。举个的例子：\nimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;const Hello = () =&gt; &#123;  const [name, setName] = useState&lt;string&gt;(&quot;smith&quot;);  const [age, setAge] = useState&lt;number&gt;(20);  useEffect(() =&gt; &#123;    console.log(&quot;name changed&quot;);    console.log(&quot;age changed&quot;);  &#125;, [name, age]);  function handleChangeName() &#123;    setName(&quot;joyce&quot;);  &#125;  function handleChangeAge() &#123;    setAge(40);  &#125;  return (    &lt;div&gt;      name: &lt;span&gt;&#123;name&#125;&lt;/span&gt;      age: &lt;span&gt;&#123;age&#125;&lt;/span&gt;      &lt;button onClick=&#123;handleChangeName&#125;&gt;change name&lt;/button&gt;      &lt;button onClick=&#123;handleChangeAge&#125;&gt;change age&lt;/button&gt;    &lt;/div&gt;  );&#125;;\n如上代码，当name和age任何一个值改变的时候，都会触发更新(例子中表现为两个console.log都会被打印出来)，这显然是不太妥当的写法。应该只在name改变的时候打印&#39;name changed&#39;age改变的时候打印&#39;age changed&#39;。所以应该把useEffect拆分为更小且职责更单一的函数。如下：\nimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;const Hello = () =&gt; &#123;  const [name, setName] = useState&lt;string&gt;(&quot;smith&quot;);  const [age, setAge] = useState&lt;number&gt;(20);  useEffect(() =&gt; &#123;    console.log(&quot;name changed&quot;);  &#125;, [name]);  useEffect(() =&gt; &#123;    console.log(&quot;age changed&quot;);    // console.log(&quot;age changed&quot;);  &#125;, [age]);  function handleChangeName() &#123;    setName(&quot;joyce&quot;);  &#125;  function handleChangeAge() &#123;    setAge(40);  &#125;  return (    &lt;div&gt;      name: &lt;span&gt;&#123;name&#125;&lt;/span&gt;      age: &lt;span&gt;&#123;age&#125;&lt;/span&gt;      &lt;button onClick=&#123;handleChangeName&#125;&gt;change name&lt;/button&gt;      &lt;button onClick=&#123;handleChangeAge&#125;&gt;change age&lt;/button&gt;    &lt;/div&gt;  );&#125;;\n在上述例子中，如果name和age的状态在需求开发中是两个完全独立的，更好的方式，应该是将name的状态和age状态，分别独立出来写成custom hook的形式。这样代码在可读性和维护性上也会更好。\n在useEffect中使用条件判断语句当你在useEffect中使用条件语句的时候，有一些细节问题可能你并未能注意到。来举个例子：\nconst Hello = () =&gt; &#123;  const [num, setNum] = useState&lt;number&gt;(1);  useEffect(() =&gt; &#123;    if (num &lt; 3) &#123;      // num小于5的时候执行某些操作。      console.log(&quot;设置某些操作或者状态&quot;);    &#125;    return () =&gt; &#123;      // 在num更新更新之后，清除上一次的操作或者状态。      console.log(&quot;clear&quot;);    &#125;;  &#125;, [num]);  const handleClick = () =&gt; &#123;    setNum(num + 1);  &#125;;  return &lt;div onClick=&#123;handleClick&#125;&gt;number: &#123;num&#125;&lt;/div&gt;;&#125;;export default Hello;\n如上示例代码，在每次点击div元素的时候num状态进行累加，当num小于3的时候执行某些状态的设置操作等等，这里要表达的需求大致是，当num小于3的时候执行订阅或者状态的设置，随后在num更新之后清除上一次的订阅或者状态设置。可是以上示例的代码虽然在表现上符合我们的预期，但是，在后续累加大于等于3之后useEffect返回的函数都会被执行。这显然是存在代码冗余执行的问题。所以在useEffect面临条件判断的场景下，可以显示return来防止此类问题。如下：\nconst Hello = () =&gt; &#123;  const [num, setNum] = useState&lt;number&gt;(1);  useEffect(() =&gt; &#123;    if (num &gt;= 3) return;    return () =&gt; &#123;      // 在num更新更新之后，清除上一次的操作或者状态。      console.log(&quot;clear&quot;);    &#125;;  &#125;, [num]);  const handleClick = () =&gt; &#123;    setNum(num + 1);  &#125;;  return &lt;div onClick=&#123;handleClick&#125;&gt;number: &#123;num&#125;&lt;/div&gt;;&#125;;export default Hello;\n这样当num大于等于3之后，useEffect将不会执行相关的&#39;清理&#39;操作，更符合预期效果。\n","categories":["react"],"tags":["react hook"]},{"title":"tree shaking","url":"/chargoyao.github.io/2020/09/06/tree-shaking/","content":"Tree Shakingwebpack通过借鉴rollup开始在webpack2中支持Tree Shaking，在webpack4中是默认支持Tree Shaking，如果你在打包的时候设置mode为production，webpack就会默认开启Tree Shaking。使用方法：1.webpack mode属性设置为production2..babelrc里设置modules: false\n什么是Tree Shaking?(摇树优化？翻译起来感觉实在是怪)一个模块中可能有多个方法，在这种情况下，只要其中的方法使用到了，则整个文件都被会打包到bundle里面去，tree shaking就是只把用到的方法打包进bundle，没用到的方法会被remove掉。\n要了解tree Shaking的原理首先必须要提的是Dead Code Elimination(死码消除)，DCE是一种编译优化技术，它的用途是移除对程序运行结果没有任何影响的代码。\n哪些是对于程序运行没有任何影响的代码呢？1.代码不会被执行，且无法到达，比如：\nif (false) &#123;  console.log(&#x27;unused code&#x27;);  &#125;\n2.代码的执行结果没有被用到比如你写了一个函数，这个函数返回一个结果，这个结果的值在代码中并未使用到，或者你调用这个函数赋值给一个变量，但是变量的值却没有在代码中使用。3.死变量你写了一系列的代码去改变你声明的变量的值，但是最后变量并没有在代码中被用到。\n以上的情况统称为DCE，tree Shaking也是利用了这些特性从而来判断哪些代码是dead code从而删除它。\nTree Shaking的原理tree shaking其实就是利用了ES module的特点来进行shake1.只能作为模块顶层的语句出现2.import的模块名字只能是字符串常量，也就是说你不能动态的去设置import的内容3.import的binding是不可变的显然commonJS是不具备ES6的特点的，commonJS是可以动态的require。在不同的条件下去require不同的模块。Tree shaking最本质的是对模块的代码进行静态的分析,因此Tree Shaking需要ES6这样的模块特性。也就是说在代码编译阶段就要确定哪些代码是你需要的或者必须的，而不能在代码运行的时候再进行分析哪些代码是需要的。Tree shaking知道哪些代码没用之后会增加注释和标记，然后会在uglify阶段进行remove的操作。\n","categories":["webpack"],"tags":["tree shaking"]}]