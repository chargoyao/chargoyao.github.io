[{"title":"tree shaking","url":"/chargoyao.github.io/2020/09/06/tree-shaking/","content":"Tree Shakingwebpack通过借鉴rollup开始在webpack2中支持Tree Shaking，在webpack4中是默认支持Tree Shaking，如果你在打包的时候设置mode为production，webpack就会默认开启Tree Shaking。使用方法：1.webpack mode属性设置为production2..babelrc里设置modules: false\n什么是Tree Shaking?(摇树优化？翻译起来感觉实在是怪)一个模块中可能有多个方法，在这种情况下，只要其中的方法使用到了，则整个文件都被会打包到bundle里面去，tree shaking就是只把用到的方法打包进bundle，没用到的方法会被remove掉。\n要了解tree Shaking的原理首先必须要提的是Dead Code Elimination(死码消除)，DCE是一种编译优化技术，它的用途是移除对程序运行结果没有任何影响的代码。\n哪些是对于程序运行没有任何影响的代码呢？1.代码不会被执行，且无法到达，比如：\nif (false) &#123;  console.log(&#x27;unused code&#x27;);  &#125;\n2.代码的执行结果没有被用到比如你写了一个函数，这个函数返回一个结果，这个结果的值在代码中并未使用到，或者你调用这个函数赋值给一个变量，但是变量的值却没有在代码中使用。3.死变量你写了一系列的代码去改变你声明的变量的值，但是最后变量并没有在代码中被用到。\n以上的情况统称为DCE，tree Shaking也是利用了这些特性从而来判断哪些代码是dead code从而删除它。\nTree Shaking的原理tree shaking其实就是利用了ES module的特点来进行shake1.只能作为模块顶层的语句出现2.import的模块名字只能是字符串常量，也就是说你不能动态的去设置import的内容3.import的binding是不可变的显然commonJS是不具备ES6的特点的，commonJS是可以动态的require。在不同的条件下去require不同的模块。Tree shaking最本质的是对模块的代码进行静态的分析,因此Tree Shaking需要ES6这样的模块特性。也就是说在代码编译阶段就要确定哪些代码是你需要的或者必须的，而不能在代码运行的时候再进行分析哪些代码是需要的。Tree shaking知道哪些代码没用之后会增加注释和标记，然后会在uglify阶段进行remove的操作。\n","categories":["webpack"],"tags":["tree shaking"]}]