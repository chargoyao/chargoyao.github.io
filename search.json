[{"title":"react useEffect","url":"/chargoyao.github.io/2020/09/08/react-useEffect/","content":"Single Responsiblility在开发基于hook的react运用的时候可以在Function component中使用多个useEffect,既然是基于function component来组织react代码，有一个基本原则还是需要去留意的，它就是单一职责。将useEffect拆分为更小的职责更单一的函数，有利于防止&#39;意外&#39;的发生，尤其在使用dependency array的时候。举个的例子：\nimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;const Hello = () =&gt; &#123;  const [name, setName] = useState&lt;string&gt;(&quot;smith&quot;);  const [age, setAge] = useState&lt;number&gt;(20);  useEffect(() =&gt; &#123;    console.log(&quot;name changed&quot;);    console.log(&quot;age changed&quot;);  &#125;, [name, age]);  function handleChangeName() &#123;    setName(&quot;joyce&quot;);  &#125;  function handleChangeAge() &#123;    setAge(40);  &#125;  return (    &lt;div&gt;      name: &lt;span&gt;&#123;name&#125;&lt;/span&gt;      age: &lt;span&gt;&#123;age&#125;&lt;/span&gt;      &lt;button onClick=&#123;handleChangeName&#125;&gt;change name&lt;/button&gt;      &lt;button onClick=&#123;handleChangeAge&#125;&gt;change age&lt;/button&gt;    &lt;/div&gt;  );&#125;;\n如上代码，当name和age任何一个值改变的时候，都会触发更新(例子中表现为两个console.log都会被打印出来)，这显然是不太妥当的写法。应该只在name改变的时候打印&#39;name changed&#39;age改变的时候打印&#39;age changed&#39;。所以应该把useEffect拆分为更小且职责更单一的函数。如下：\nimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;const Hello = () =&gt; &#123;  const [name, setName] = useState&lt;string&gt;(&quot;smith&quot;);  const [age, setAge] = useState&lt;number&gt;(20);  useEffect(() =&gt; &#123;    console.log(&quot;name changed&quot;);  &#125;, [name]);  useEffect(() =&gt; &#123;    console.log(&quot;age changed&quot;);    // console.log(&quot;age changed&quot;);  &#125;, [age]);  function handleChangeName() &#123;    setName(&quot;joyce&quot;);  &#125;  function handleChangeAge() &#123;    setAge(40);  &#125;  return (    &lt;div&gt;      name: &lt;span&gt;&#123;name&#125;&lt;/span&gt;      age: &lt;span&gt;&#123;age&#125;&lt;/span&gt;      &lt;button onClick=&#123;handleChangeName&#125;&gt;change name&lt;/button&gt;      &lt;button onClick=&#123;handleChangeAge&#125;&gt;change age&lt;/button&gt;    &lt;/div&gt;  );&#125;;\n在上述例子中，如果name和age的状态在需求开发中是两个完全独立的，更好的方式，应该是将name的状态和age状态，分别独立出来写成custom hook的形式。这样代码在可读性和维护性上也会更好。\n在useEffect中使用条件判断语句当你在useEffect中使用条件语句的时候，有一些细节问题可能你并未能注意到。来举个例子：\nconst Hello = () =&gt; &#123;  const [num, setNum] = useState&lt;number&gt;(1);  useEffect(() =&gt; &#123;    if (num &lt; 3) &#123;      // num小于5的时候执行某些操作。      console.log(&quot;设置某些操作或者状态&quot;);    &#125;    return () =&gt; &#123;      // 在num更新更新之后，清除上一次的操作或者状态。      console.log(&quot;clear&quot;);    &#125;;  &#125;, [num]);  const handleClick = () =&gt; &#123;    setNum(num + 1);  &#125;;  return &lt;div onClick=&#123;handleClick&#125;&gt;number: &#123;num&#125;&lt;/div&gt;;&#125;;export default Hello;\n如上示例代码，在每次点击div元素的时候num状态进行累加，当num小于3的时候执行某些状态的设置操作等等，这里要表达的需求大致是，当num小于3的时候执行订阅或者状态的设置，随后在num更新之后清除上一次的订阅或者状态设置。可是以上示例的代码虽然在表现上符合我们的预期，但是，在后续累加大于等于3之后useEffect返回的函数都会被执行。这显然是存在代码冗余执行的问题。所以在useEffect面临条件判断的场景下，可以显示return来防止此类问题。如下：\nconst Hello = () =&gt; &#123;  const [num, setNum] = useState&lt;number&gt;(1);  useEffect(() =&gt; &#123;    if (num &gt;= 3) return;    return () =&gt; &#123;      // 在num更新更新之后，清除上一次的操作或者状态。      console.log(&quot;clear&quot;);    &#125;;  &#125;, [num]);  const handleClick = () =&gt; &#123;    setNum(num + 1);  &#125;;  return &lt;div onClick=&#123;handleClick&#125;&gt;number: &#123;num&#125;&lt;/div&gt;;&#125;;export default Hello;\n这样当num大于等于3之后，useEffect将不会执行相关的&#39;清理&#39;操作，更符合预期效果。\n","categories":["react"],"tags":["react hook"]},{"title":"es2020新特性","url":"/chargoyao.github.io/2020/10/13/es2020/","content":"自从2015年发布了ES6之后，每年TC39都会发布新版的ECMA规范，ECMA2020是发布的第十一个ECMA版本。\nglobalThis如今的javascript语言几乎无所不能，从web端到后端到客户端都能通吃。不同的环境使用的是不一样的对象。比如：浏览器使用的是window，nodejs使用的是global，而Service Worker使用的是self。而现在一般的做法都会通过一个通用函数来判断不同平台。新的ECMA2020中，则将此全局对象统一收敛为globalThis；\nPromise.allSettled()Promose.allSettled()返回一个promise,此方法的参数为一个数组的promise，数组中的每一个promise无论是resolve还是reject，Promise.allSettled()都将进入resovle状态，其then参数为函数status属性的对象。如下：\nconst p1 = new Promise((res) =&gt; res(&#x27;one&#x27;));const p2 = new Promise((res, rej) =&gt; rej(&#x27;two&#x27;));const p3 = new Promise((res) =&gt; res(&#x27;three&#x27;));Promise.allSettled([p1, p2, p3]).then(data =&gt; console.log(data));\n打印如下：\n[  &#123;    status: &#39;fulfilled&#39;, value: &#39;one&#39;,   &#125;,  &#123;    status: &#39;rejected&#39;, value: &#39;two&#39;,   &#125;,  &#123;    status: &#39;fulfilled&#39;, value: &#39;three&#39;,   &#125;]\n#Nullish联合操作符Nullish联合操作符主要用在对象属性的读取上。类似于&amp;&amp;和||操作符，当操作符的左边为null或者undefined的时候，返回操作符右边的结果。如下：\nlet data = &#123;&#125;;let name = data.name ?? &quot;chargo&quot;; // chargodata = &#123;name: &#x27;yao&#x27;&#125;;name = data.name ?? &#x27;yao&#x27;; // name为yao\nOptional Chaining Operator通常读取嵌套对象属性值的时候都需要先判断是否是null或者undefined。然后在进行进一步的代码执行(比如值的读取)。比如：\n// 读取DOMconst ele = document.querySelector(&#x27;input[name=age]&#x27;);const val = ele &amp;&amp; ele.value;\n在es2020中有了Optional Chaining Operator你可以这么写：\nconst val = document.querySelector(&#x27;input[name=age]&#x27;)?.value;\n如上如果操作符?.左侧返回的是null或者undefined的话将不会执行操作符右侧值的读取。\n","categories":["javascript"],"tags":["es2020"]},{"title":"Javascript function","url":"/chargoyao.github.io/2020/09/08/Javascript-function/","content":"Javascript语言支持functional programming,其中一个主要的原因是函数在js中是作为first-class citizens存在的。在js中函数究竟有哪些用法？\nPure Function在函数式编程中其中有一个很重要的概念，那就是纯函数，究竟什么样的函数才能称为纯函数呢？纯函数应该满足下面两个条件：1.给定相同的参数总是返回相同的结果。2.在函数执行期间不存在side-effect(副作用)。\n例子：\nfunction add(a: number) &#123; return 2 * a + 10; &#125;\n当a的值是相同的时候，add函数总是返回相同的值，并且函数的外部不存在任何的side-effect。(add函数的执行并不依赖于任何外部环境的变量)。所以这里的add函数是个pure function。\n    const num: () =&gt; number = (function() &#123;  let i = 0;   return function() &#123;    i++;    return i;  &#125; &#125;)();\n此处的num函数在每次调用的时候都返回不同的值，因此它不是一个纯函数。\nWhy pure function?为什么要有纯函数的概念呢？它的优点在哪里？纯函数主要有以下优点：\n纯函数可以让代码更易测试比如下面这个具有副作用的函数\nlet outsideVar = 10;// calculateValue函数依赖外部环境变量export const calculateValue = (value: number) =&gt; value * 2 + outsideVar;\n测试代码\ndescribe(&#x27;测试不纯的函数&#x27;, () =&gt; &#123;  it(&#x27;should be 12&#x27;, () =&gt; &#123;    expect(calculateValue(1)).toBe(12);  &#125;);&#125;);\n上面的测试是可以通过，但是假设如果外部环境的变量被改变了的话，这条测试可能就无法测试通过。此时的calculateValue函数就难以测试。如果要修复这样的问题，我们可以通过将外部环境变量移入calculateValue函数中来解决。\n并发执行代码由于纯函数并不会改变它的环境，因此纯函数可以并发的执行代码。也就是说你不需要担心同步的问题。当然javascript并没有真正的多线程用来并发的执行代码。但是当你的项目使用了WebWorker之后，你可能会用WebWorker来并发的执行多任务。比如有个非纯函数的代码版本：\nlet name = &#x27;python&#x27;;function foo() &#123;  name = &#x27;php&#x27;;  // other code&#125;function bar() &#123;        if (name === &#x27;python&#x27;) &#123;    console.log(&#x27;business logic&#x27;);  &#125;&#125;\n以上代码假设D1线程执行了foo函数，D2线程执行了bar函数。且D1在D2之前执行，由于二者皆依赖于全局变量，最终的执行结果可能并不会是你想要的。因此可以将上述的两个函数改造为纯函数，移动name变量，如下：\nfunction foo(name: string) &#123;  name = &#x27;php&#x27;;  // other code&#125;function bar(name: string) &#123;        if (name === &#x27;python&#x27;) &#123;    console.log(&#x27;business logic&#x27;);  &#125;&#125;\n现在你可以放心的并发的执行这两个函数了，且不必但是顺序的问题。\nhigh-order function什么是高阶函数？定义：以一个或者多个函数作为参数，或者函数返回的是一个函数。或者如上两者情况皆有的函数称为高阶函数。借助于高阶函数可以让你的代码更具灵活性，同时也更加有效和精炼。打个比方，比如有一个正整数的数组，现在需要生成一个新的数组，且数组的元素是原来数组元素值的两倍。在不使用高阶函数的时候你可能会这么写代码：\nconst arr1 = [1, 2, 3];const arr2 = [];for (let i = 0; i &lt; arr1.length; i++) &#123;  arr2.push(arr1[i] * 2);&#125;\n在js中有个操作数组对象的方法map，map方法的参数传入指定的函数会返回一个新的数组，这个map其实就是一个high-order function。\nconst arr1 = [1, 2, 3];const arr2 = arr1.map((item: number) =&gt; number * 2);\n通过使用这样的高阶函数可以有效增强代码的可读性，这样的代码更像是一种声明式编程的范式，而非命令式编程。\nCache Function比如有如下需要一定计算开销的pure function。\nfunction computedValue() &#123;    // 这里有开销大的计算    console.log(&#x27;computing&#x27;);  return &#x27;computed value&#x27;;&#125;\n利用pure function相同的参数总是返回相同结果的特性，就可以缓存函数的计算结果，如果函数的参数是相同的就可以从内存中直接返回结果，而无需再一次执行函数。从而提高代码执行的性能，其实也就是利用空间换时间的概念。通过如下的缓存函数可以缓存pure function的计算结果。\nfunction cacheWrapper(fn) &#123;  const cacheMap = &#123;&#125;;  return function cachedFn(str) &#123;    return cacheMap[str] || (cacheMap[str] = fn(str));  &#125;&#125;\nLazy Function有时候函数体会包含一些条件判断语句，有时候这些条件判断语句只需要执行一次。可以在函数首次执行完毕之后，删除这些判断语句从而达到提高函数执行性能的目的。在之后函数再一次执行的时候则不需要经过条件语句的判断，这样的技术称为lazy function。举个例子，在你需要兼容老式的IE浏览器的时候，可能会写如下的兼容代码\nfunction addEvent(type, element, fn) &#123;  if (window.addEventListener) &#123;    element.addEventListener(type, fn, false);  &#125; else if (window.attachEvent) &#123;    element.attachEvent(&#x27;on&#x27; + type, fn);  &#125; &#125;\n每次调用这个addEvent函数的时候，都要执行一遍if语句的条件判断，通过lazy function技术可以这么做：\nfunction addEvent() &#123;  if (window.addEventListener) &#123;    addEvent = function(type, element, fn) &#123;      element.addEvenListener(type, fn, false);    &#125;   &#125; else if (window.attachEvent) &#123;    addEvent = function(type, element, fn) &#123;      element.attachEvent(&#x27;on&#x27; + type, fn);    &#125;   &#125;  addEvent(type, element, fn);&#125;\n对于一些函数中的条件判断语句只需要执行一次的场景，可以通过lazy function来进行优化，第一次函数中的条件判断语句被执行之后，原函数的函数体被新的无条件判断语句的函数覆盖。\n","categories":["functional programming"],"tags":["javascript"]},{"title":"tree shaking","url":"/chargoyao.github.io/2020/09/06/tree-shaking/","content":"Tree Shakingwebpack通过借鉴rollup开始在webpack2中支持Tree Shaking，在webpack4中是默认支持Tree Shaking，如果你在打包的时候设置mode为production，webpack就会默认开启Tree Shaking。使用方法：1.webpack mode属性设置为production2..babelrc里设置modules: false\n什么是Tree Shaking?(摇树优化？翻译起来感觉实在是怪)一个模块中可能有多个方法，在这种情况下，只要其中的方法使用到了，则整个文件都被会打包到bundle里面去，tree shaking就是只把用到的方法打包进bundle，没用到的方法会被remove掉。\n要了解tree Shaking的原理首先必须要提的是Dead Code Elimination(死码消除)，DCE是一种编译优化技术，它的用途是移除对程序运行结果没有任何影响的代码。\n哪些是对于程序运行没有任何影响的代码呢？1.代码不会被执行，且无法到达，比如：\nif (false) &#123;  console.log(&#x27;unused code&#x27;);  &#125;\n2.代码的执行结果没有被用到比如你写了一个函数，这个函数返回一个结果，这个结果的值在代码中并未使用到，或者你调用这个函数赋值给一个变量，但是变量的值却没有在代码中使用。3.死变量你写了一系列的代码去改变你声明的变量的值，但是最后变量并没有在代码中被用到。\n以上的情况统称为DCE，tree Shaking也是利用了这些特性从而来判断哪些代码是dead code从而删除它。\nTree Shaking的原理tree shaking其实就是利用了ES module的特点来进行shake1.只能作为模块顶层的语句出现2.import的模块名字只能是字符串常量，也就是说你不能动态的去设置import的内容3.import的binding是不可变的显然commonJS是不具备ES6的特点的，commonJS是可以动态的require。在不同的条件下去require不同的模块。Tree shaking最本质的是对模块的代码进行静态的分析,因此Tree Shaking需要ES6这样的模块特性。也就是说在代码编译阶段就要确定哪些代码是你需要的或者必须的，而不能在代码运行的时候再进行分析哪些代码是需要的。Tree shaking知道哪些代码没用之后会增加注释和标记，然后会在uglify阶段进行remove的操作。\n","categories":["webpack"],"tags":["tree shaking"]}]